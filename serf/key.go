package serf

import (
	"encoding/base64"
	"fmt"
)

// keyRequest is used to encapsulate a modification request to the keyring
type keyRequest struct {
	serf *Serf

	// query is the name of the internal query to perform
	query string

	// key is the base64-encoded value of the key being operated on.
	key string

	// response is a pointer to a keyResponse to be populated with result data
	resp *KeyResponse
}

// KeyResponse is used to deliver the results of a key query
type KeyResponse struct {
	// Messages is a mapping of node name to message. Messages can be any
	// message that the node needs to relay back to indicate its result.
	Messages map[string]string

	// Replies is the total number of replies to the query.
	Replies int

	// Errors is the number of errors generated by hosts in the query.
	Errors int

	// Err contains any error thrown while constructing or executing the query.
	// If this value is nil, and Errors is greater than zero at completion,
	// then this will be automatically set to an error summary message.
	Err error
}

// newKeyResponse creates a new key response and allocates substructures
func newKeyResponse() *KeyResponse {
	return &KeyResponse{
		Messages: make(map[string]string),
		Replies:  0,
		Err:      nil,
	}
}

// Process is used to perform an internal query accross all members in a cluster
// and modify keyring data. This function manages distributing key commands to
// our members and aggregating their responses into a KeyResponse.
func (kr *keyRequest) Process() *KeyResponse {
	resp := newKeyResponse()

	// Decode the new key into raw bytes before storing it away. This ensures
	// that later on when we go to copy the new key into the memberlist config
	// there will be no decoding errors, which would cause cluster segmentation.
	rawKey, err := base64.StdEncoding.DecodeString(kr.key)
	if err != nil {
		resp.Err = err
		return resp
	}

	qParam := &QueryParam{}
	queryResp, err := kr.serf.Query(kr.query, rawKey, qParam)
	if err != nil {
		resp.Err = err
		return resp
	}

	for r := range queryResp.respCh {
		var nodeResponse nodeKeyResponse

		resp.Replies++

		// Decode the response
		if len(r.Payload) < 1 || messageType(r.Payload[0]) != messageKeyResponseType {
			resp.Messages[r.From] = fmt.Sprintf(
				"Invalide response type: %v", r.Payload)
			resp.Errors++
			continue
		}
		if err := decodeMessage(r.Payload[1:], &nodeResponse); err != nil {
			resp.Messages[r.From] = fmt.Sprintf(
				"Failed to decode response: %v", r.Payload)
			resp.Errors++
			continue
		}

		if !nodeResponse.Result {
			resp.Messages[r.From] = nodeResponse.Message
			resp.Errors++
		}
	}

	totalMembers := kr.serf.memberlist.NumMembers()

	if resp.Errors != 0 {
		resp.Err = fmt.Errorf("%d/%d nodes reported failures", resp.Errors, totalMembers)
	}
	return resp
}
